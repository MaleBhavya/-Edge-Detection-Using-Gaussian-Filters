# -*- coding: utf-8 -*-
"""lfvm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0CZjzAB9P-uEk91UmBmonX9c-7ggFPW
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
from scipy import ndimage

# Function to apply Gaussian filter for smoothing
def apply_gaussian_filter(image, sigma):
    x_range = np.arange(-3 * sigma, 3 * sigma + 1, 1)  # Define the kernel range based on sigma
    gaussian_kernel = calculate_gaussian(x_range, sigma)  # Generate the Gaussian kernel
    smoothed_x = ndimage.convolve(image.astype(float), gaussian_kernel.reshape(1, -1))  # Convolve with the Gaussian in x direction
    smoothed_y = ndimage.convolve(image.astype(float), gaussian_kernel.reshape(-1, 1))  # Convolve with the Gaussian in y direction
    return smoothed_x, smoothed_y

# Function to calculate Gaussian and Gaussian Derivative Kernels
def calculate_gaussian_kernels(sigma):
    x_range = np.arange(-3 * sigma, 3 * sigma + 1, 1)  # Define kernel range
    gaussian_kernel = calculate_gaussian(x_range, sigma)  # Calculate the Gaussian kernel
    gaussian_derivative_kernel = calculate_gaussian_derivative(x_range, sigma)  # Calculate the Gaussian derivative kernel
    return gaussian_kernel, gaussian_derivative_kernel

# Function to calculate Gaussian function
def calculate_gaussian(x, sigma):
    denominator = 2 * np.pi * sigma ** 2  # Gaussian denominator based on sigma
    exponent_part = - ((x ** 2) / (2 * sigma ** 2))  # Exponential component of Gaussian
    return 1.0 / denominator * np.exp(exponent_part)  # Return Gaussian function values

# Function to calculate the derivative of the Gaussian function
def calculate_gaussian_derivative(x, sigma):
    scaling_factor = -x / (sigma ** 3)  # Derivative scaling factor based on x and sigma
    exponent_part = np.exp(- (x ** 2) / (2 * sigma ** 2))  # Exponential component of derivative
    normalization_factor = 1.0 / (np.sqrt(2 * np.pi) * sigma)  # Normalization factor
    return exponent_part * scaling_factor * normalization_factor  # Return Gaussian derivative function

# Function to detect edges using the derivative of the Gaussian function
def detect_edges(image, gaussian_derivative_kernel):
    edge_x = ndimage.convolve(image.astype(float), gaussian_derivative_kernel.reshape(1, -1))  # Convolve with the Gaussian derivative in x direction
    edge_y = ndimage.convolve(image.astype(float), gaussian_derivative_kernel.reshape(-1, 1))  # Convolve with the Gaussian derivative in y direction
    return edge_x, edge_y

# Function to calculate gradient magnitude
def compute_gradient_magnitude(edge_x, edge_y):
    return np.sqrt(np.square(edge_x) + np.square(edge_y))  # Return the gradient magnitude based on x and y components

# Function to calculate the orientation of edges
def compute_orientation(edge_x, edge_y):
    return np.arctan2(edge_y, edge_x)  # Return the orientation in radians

# Function to visualize orientation using a color map
def visualize_orientation(orientation):
    normalized_orientation = (orientation + np.pi) / (2 * np.pi)  # Normalize orientation values to [0, 1] range
    orientation_colormap = plt.cm.hsv(normalized_orientation)  # Apply HSV color map to visualize orientation
    orientation_rgb = (orientation_colormap[:, :, :3] * 255).astype(np.uint8)  # Convert to RGB image format
    return orientation_rgb

# Function to perform non-maximum suppression on the gradient magnitude
def non_maximum_suppression(gradient_magnitude, edge_x, edge_y):
    edge_direction = np.arctan2(edge_y, edge_x)  # Compute the edge direction (orientation)
    quantized_direction = (np.round(edge_direction * (4.0 / np.pi)) + 4) % 4  # Quantize directions into 4 main categories
    nms_result = np.zeros_like(gradient_magnitude)  # Initialize NMS result image

    # Loop over the image and apply non-maximum suppression
    for i in range(1, gradient_magnitude.shape[0] - 1):
        for j in range(1, gradient_magnitude.shape[1] - 1):
            nms_result[i, j] = apply_nms(gradient_magnitude, quantized_direction, i, j)  # Apply NMS to each pixel

    return nms_result  # Return the suppressed result

# Helper function for non-maximum suppression
def apply_nms(gradient_magnitude, quantized_direction, i, j):
    if quantized_direction[i, j] == 0:  # Horizontal direction
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i, j - 1], gradient_magnitude[i, j + 1]) else 0
    elif quantized_direction[i, j] == 1:  # Diagonal (top-right to bottom-left) direction
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j + 1], gradient_magnitude[i + 1, j - 1]) else 0
    elif quantized_direction[i, j] == 2:  # Vertical direction
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j], gradient_magnitude[i + 1, j]) else 0
    else:  # Diagonal (top-left to bottom-right) direction
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j - 1], gradient_magnitude[i + 1, j + 1]) else 0

# Function for Hysteresis Thresholding
def hysteresis_thresholding(nms_result):
    high_threshold = np.percentile(nms_result, 90)  # Compute high threshold value at 90th percentile
    low_threshold = high_threshold / 3.0  # Set low threshold as a third of the high threshold

    edge_map = np.zeros_like(nms_result)  # Initialize edge map
    strong_x, strong_y = np.where(nms_result >= high_threshold)  # Find strong edges
    weak_x, weak_y = np.where((nms_result <= high_threshold) & (nms_result >= low_threshold))  # Find weak edges

    edge_map[strong_x, strong_y] = 255  # Mark strong edges as white
    edge_map[weak_x, weak_y] = 50  # Mark weak edges as gray

    return process_weak_edges(edge_map)  # Return the processed edge map after connecting weak edges

# Function to process weak edges by connecting them to strong edges
def process_weak_edges(edge_map):
    image_height, image_width = edge_map.shape  # Get image dimensions

    # Loop through the image and check weak edges' neighbors
    for i in range(1, image_height - 1):
        for j in range(1, image_width - 1):
            if edge_map[i, j] == 50:  # Check weak edges
                if 255 in [edge_map[i + 1, j - 1], edge_map[i + 1, j], edge_map[i + 1, j + 1],  # Check for strong neighbors
                           edge_map[i, j - 1], edge_map[i, j + 1],
                           edge_map[i - 1, j - 1], edge_map[i - 1, j], edge_map[i - 1, j + 1]]:
                    edge_map[i, j] = 255  # Connect weak edge to strong edge
                else:
                    edge_map[i, j] = 0  # Remove weak edge if not connected
    return edge_map  # Return the final edge map

# Function to plot the results (with the original image added as the first plot)
def plot_results(original_image, smoothed_x, smoothed_y, edge_x, edge_y, gradient_magnitude, orientation_image, nms_result, edge_map, sigma_value):
    plt.figure(figsize=(20, 16))  # Set figure size
    plt.suptitle(f'Edge Detection Results for Sigma = {sigma_value}', fontsize=16)

    plt.subplot(3, 4, 1)
    plt.imshow(original_image, cmap="gray")  # Plot the original image
    plt.title("Original Image")

    plt.subplot(3, 4, 2)
    plt.imshow(smoothed_x, cmap="gray")  # Plot smoothed image in x direction
    plt.title("X Smoothed with Gaussian")

    plt.subplot(3, 4, 3)
    plt.imshow(smoothed_y, cmap="gray")  # Plot smoothed image in y direction
    plt.title("Y Smoothed with Gaussian")

    plt.subplot(3, 4, 4)
    plt.imshow(edge_x, cmap="gray")  # Plot edge detection in x direction
    plt.title("X Edge Detection")

    plt.subplot(3, 4, 5)
    plt.imshow(edge_y, cmap="gray")  # Plot edge detection in y direction
    plt.title("Y Edge Detection")

    plt.subplot(3, 4, 6)
    plt.imshow(gradient_magnitude, cmap="gray")  # Plot gradient magnitude
    plt.title("Gradient Magnitude")

    plt.subplot(3, 4, 7)
    plt.imshow(nms_result, cmap="gray")  # Plot result after Non-Maximum Suppression
    plt.title("Non-Maximum Suppression")

    plt.subplot(3, 4, 8)
    plt.imshow(orientation_image)  # Plot orientation (color-mapped)
    plt.title("Orientation (Color Mapped)")

    # plt.subplot(3, 4, 9)
    # plt.imshow(edge_map, cmap="gray")  # Plot final edge map after hysteresis thresholding
    # plt.title("Hysteresis Thresholding")

    plt.tight_layout()  # Adjust layout to avoid overlap
    plt.show()  # Show the plots

# Main function to perform the edge detection workflow
def main(image, sigma):
    # Step 1: Apply Gaussian Smoothing
    smoothed_x, smoothed_y = apply_gaussian_filter(image, sigma)

    # Step 2: Calculate Gaussian derivative kernels and detect edges
    _, gaussian_derivative_kernel = calculate_gaussian_kernels(sigma)
    edge_x, edge_y = detect_edges(image, gaussian_derivative_kernel)

    # Step 3: Compute the gradient magnitude
    gradient_magnitude = compute_gradient_magnitude(edge_x, edge_y)

    # Step 4: Perform non-maximum suppression
    nms_result = non_maximum_suppression(gradient_magnitude, edge_x, edge_y)

    # Step 5: Compute orientation of edges (AFTER NMS)
    orientation = compute_orientation(edge_x, edge_y)
    orientation_image = visualize_orientation(orientation)  # Create the color-mapped orientation image

    # Step 6: Apply hysteresis thresholding to refine the edges
    edge_map = hysteresis_thresholding(nms_result)

    # Step 7: Plot the results (including the original image)
    plot_results(image, smoothed_x, smoothed_y, edge_x, edge_y, gradient_magnitude, orientation_image, nms_result, edge_map, sigma)

# Load the image (update the path to match your environment)
input_image = cv2.imread('/content/67079.jpg', 0)  # Load the image in grayscale mode

# Check if the image was loaded correctly
if input_image is None:
    print("Error: Image not found or unable to load. Please check the file path.")
else:
    # Define sigma values for Gaussian filter
    sigma_values = [0.7, 0.9, 1]

    # Loop through the sigma values and apply the edge detection
    for sigma_value in sigma_values:
        main(input_image, sigma_value)  # Run the main function for each sigma value